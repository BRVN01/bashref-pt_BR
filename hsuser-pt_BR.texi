@ignore
Este arquivo documenta a interface de usuário para a biblioteca GNU 
History.

Direitos autorais @copyright{} 2015 da versão modificada traduzida para 
o português do Brasil: Jamenson Ferreira Espindula de Almeida Melo.

Direitos autorais @copyright{} 1988--2014 Free Software Foundation, Inc.

Da autoria de Brian Fox e Chet Ramey.

É dada permissão para processar este arquivo por meio de Tex e imprimir 
o resultado, contanto que o documento impresso carregue uma notícia de 
permissão de cópia idêntica a esta, exceto pela remoção deste parágrafo 
(este parágrafo não sendo relevante para o manual impresso).

É dada permissão para produzir e distribuir cópias literais deste 
manual, contanto que a notícia de direitos autorais e esta notícia de 
permissão sejam preservadas em todas as cópias.

É dada permissão para copiar e distribuir versões modificadas deste 
manual sob as condições para cópias literais, contanto também que a 
declaração de Direitos Autorais GNU esteja disponível para o 
distribuidor, e contanto que o trabalho derivado resultante inteiro seja 
distribuído sob os termos de uma notícia de permissão idêntica a esta.

É dada permissão para copiar e distribuir traduções deste manual em 
outra língua, sob as condições acima para versões modificadas.
@end ignore

@node Using History Interactively
@chapter Using History Interactively

@ifclear BashFeatures
@defcodeindex bt
@end ifclear

@ifset BashFeatures
Este capítulo descreve como utilizar a biblioteca @sc{gnu} History 
interativamente, a partir do ponto de vista do usuário.
Ele deveria ser considerado um guia do usuário.
Para informação sobre a utilização da biblioteca @sc{gnu} History em 
outros programas, veja-se o Manual da Biblioteca @sc{gnu} Readline.
@end ifset
@ifclear BashFeatures
Este capítulo descreve como utilizar a Biblioteca @sc{gnu} History 
interativamente, a partir do ponto de vista do usuário.   Ele deveria 
ser consideradoum guia do usuário.   Para informação sobre a utilização 
da Biblioteca @sc{gnu} History em seus próprios programas, veja-se 
@ref{Programming with GNU History}.
@end ifclear

@ifset BashFeatures
@menu
* Bash History Facilities::	Como Bash te permite manipular seu 
histórico de comando.
* Bash History Builtins::	Os comandos internos de Bash que 
manipulam o histórico de comando.
* History Interaction::		Qual é o sentimento ao se utilizar 
History como um usuário.
@end menu
@end ifset
@ifclear BashFeatures
@menu
* History Interaction::		Qual é o sentimento ao se utilizar 
History como um usuário.
@end menu
@end ifclear

@ifset BashFeatures
@node Bash History Facilities
@section Bash History Facilities
@cindex command history
@cindex history list

Quando a opção @option{-o history} ao comando interno @code{set} está 
habilitada (veja-se @ref{The Set Builtin}), o shell provê acesso ao 
@dfn{histórico de comandos}, a lista de comandos previamente digitados.
O valor da variável de shell @env{HISTSIZE} é utilizada como o número de 
comandos a salvar em uma lista de histórico.
O texto dos últimos @env{$HISTSIZE} comandos (padrão 500) é salvo.
O shell armazena cada comando em uma lista de histórico prévia a 
expansão de parâmetro e variável, porém após a expansão de histórico ser 
realizada, objeto dos valores das variáveis de shell @env{HISTIGNORE} e 
@env{HISTCONTROL}.

Quando o shell inicializa, o histórico é inicializado a partir do 
arquivo noneado pela variável @env{HISTFILE} (padrão 
@file{~/.bash_history}).
O arquivo nomeado pelo valor de @env{HISTFILE} é truncado, se 
necessário, para conter não mais que o número de linhas especificadas 
pelo valor da variável @env{HISTFILESIZE}.
Quando um shell com histórico habilitado sai, as últimas @env{$HISTSIZE} 
linhas são copiadas a partir da lista de histórico para o arquivo 
nonimado por @env{$HISTFILE}.
Se a opção de shell @code{histappend} for configurada 
(veja-se @ref{Bash Builtins}), então as linhas são acrescentadas ao 
final do arquivo de histórico, do contrário o arquivo de histórico é 
sobrescrito.
Se @env{HISTFILE} for desconfigurada, ou se o arquivo de histórico 
estiver sem permissão de escrita, então o histórico não é salvo.
Após o salvamento do histórico, o arquivo de histórico é truncado para 
conter não mais que @env{$HISTFILESIZE} linhas.
Se @env{HISTFILESIZE} estiver desconfigurada, ou configurada para 
"null", para um valor não numérico ou um valor numérico menor que zero, 
então o arquivo de histórico não é truncado.

Se a @env{HISTTIMEFORMAT} estiver configurada, então a informação de 
marca temporal associada com cada entrada de histórico é escrita no 
arquivo de histórico, marcada com o carácter de comentário de histórico.
Quando o arquivo de histórico é lido, as linhas iniciando com o carácter 
de comentário de histórico seguidas imediatamente por um dígito são 
interpretadas como marcas temporais para a linha de histórico prévia.

O comando interno @code{fc} pode ser utilizado para listar ou editar e 
re-executar uma porção da lista de histórico.
O comando interno @code{history} pode ser utilizado para exibir ou 
modificar a lista de histórico e manipular o arquivo de histórico.
Quando da utilização da edição de linha de comando, os comandos de busca 
estão disponíveis em cada modo de edição que provê acesso à lista de 
histórico (veja-se @ref{Commands For History}).

O shell permite controle sobre quais comandos são salvos na lista de 
histórico.   As variáveis @env{HISTCONTROL} e @env{HISTIGNORE} podem ser 
configuradas para fazer com que o shell salve somente um subconjunto dos 
comandos fornecidos.
A opção de shell @code{cmdhist}, se habilitada, faz com que o shell 
tente salvar cada linha de um comando multi-linha na mesma entrada de 
histórico, adicionando ponto e vírgula onde for necessário para 
preservar a correção sintática.
A opção de shell @code{lithist} faz com o shell salve o comando com 
marcadores "newline" embutidos, em vez de ponto e vírgula.
O comando interno @code{shopt} é utilizado para configurar essas opções.
Veja-se @ref{Bash Builtins}, para uma descrição de @code{shopt}.

@node Bash History Builtins
@section Bash History Builtins
@cindex history builtins

Bash provê dois comandos internos os quais manipulam a lista de 
histórico e o arquivo de histórico.

@table @code

@item fc
@btindex fc
@example
@code{fc [-e @var{ename}] [-lnr] [@var{first}] [@var{last}]}
@code{fc -s [@var{pat}=@var{rep}] [@var{command}]}
@end example

A primeira forma seleciona um intervalo de comandos, desde @var{first} 
até @var{last}, da lista de histórico e exibe ou edita e os re-executa.
@var{first} e @var{last} podem ser especificadas como uma sequência de 
caracteres (para localizar o mais recente comando iniciando com aquela 
sequência de caracteres) ou como um número (um indice na lista de 
histórico, onde um número negativo é utilizado como uma compensação a 
partir do número atual de comando).   Se @var{last} não for 
especificado, então é configurado para @var{first}.   Se @var{first} não 
for especificado, então é configurado para o comando prévio para edição 
e @minus{}16 para listagem.   Se o sinalizador @option{-l} for dado, 
então os comandos são listados na saída padrão.  O sinalizador 
@option{-n} suprime os números de comando quando da listagem.   O 
sinalizador @option{-r} reverte a ordem da listagem.   Do contrário, o 
editor dado por @var{ename} é invocado sobre um arquivo contendo aqueles 
comandos.   Se @var{ename} não for dado, então o valor da seguinte 
expansão de variável é utilizado: @code{$@{FCEDIT:-$@{EDITOR:-vi@}@}}. 
Isso diz para utilizar o valor da variável @env{FCEDIT} se configurado, 
ou o valor da variável @env{EDITOR} se essa estiver configurada, ou 
@code{vi} se nenhuma delas estiver configurada.
Quando a edição estiver completa, os comandos editados são ecoados e 
executados.

Na segunda forma, @var{command} é re-executado após cada instância de 
@var{pat} no comando selecionado ser substituida por @var{rep}.
@var{command} é interpretado do mesmo jeito que @var{first} acima.

Um apelido útil para se utilizar com o comando @code{fc} é 
@code{r='fc -s'}, de maneira que digitar @samp{r cc} executa o último 
comando iniciando com @code{cc} e digitar @samp{r} re-executa o último 
comando (veja-se @ref{Aliases}).

@item history
@btindex history
@example
history [@var{n}]
history -c
history -d @var{offset}
history [-anrw] [@var{filename}]
history -ps @var{arg}
@end example

Sem opções, exibe a lista de histórico com números de linha.
As linhas prefixadas com um @samp{*} foram modificadas.
Um argumento de @var{n} lista somente as últimas @var{n} linhas.
Se a variável de shell @env{HISTTIMEFORMAT} estiver configurada e não 
nula, então ela é utilizada como uma sequência de caracteres de formato 
para @var{strftime} exibir a marca temporal associada com cada entrada 
de histórico exibida.
Nenhum espaço em branco interveniente é impresso entre a marca temporal 
formatada e a linha de histórico.

As opções, se fornecidas, tem os seguintes significados:

@table @code
@item -c
Limpa a lista de histórico.   Isso pode ser combinado com as outras 
opções para substituir a lista de histórico completamente.

@item -d @var{offset}
Deleta a entrada de histórico na posição @var{offset}.
@var{offset} deveria ser especificado conforme aparece quando o 
histórico é exibido.

@item -a
Acrescenta ao final as novas linhas de histórico (linhas de histórico 
entradas desde o início da sessão atual de Bash) ao arquivo de 
histórico.

@item -n
Acrescenta as linhas de histórico ainda não lidas a partir do arquivo de 
histórico à atual lista de histórico.   Essas são linhas adicionadas ao 
arquivo de histórico desde o início da sessão atual de Bash.

@item -r
Lê o arquivo de histórico e adiciona seu conteúno à lista de histórico.

@item -w
Escreve a atual lista de histórico ao arquivo de histórico.

@item -p
Realiza substituição de histórico sobre os @var{arg}s e exibe o 
resultado na sa'da padrão, sem armazenar os resultados na lista de 
histórico.

@item -s
Os @var{arg}s são adicionados ao final da lista de histórico como uma 
entrada única.

@end table

Quando qualquer das opções @option{-w}, @option{-r}, @option{-a}, ou 
@option{-n} é utilizada, se @var{filename} for dado, então ele é 
utilizado como o arquivo de histórico.   Se não, então o valor da 
variável @env{HISTFILE} é utilizada.

@end table
@end ifset

@node History Interaction
@section History Expansion
@cindex history expansion

The History library provides a history expansion feature that is similar
to the history expansion provided by @code{csh}.  This section
describes the syntax used to manipulate the history information.

History expansions introduce words from the history list into
the input stream, making it easy to repeat commands, insert the
arguments to a previous command into the current input line, or
fix errors in previous commands quickly.

History expansion takes place in two parts.  The first is to determine
which line from the history list should be used during substitution.
The second is to select portions of that line for inclusion into the
current one.  The line selected from the history is called the
@dfn{event}, and the portions of that line that are acted upon are
called @dfn{words}.  Various @dfn{modifiers} are available to manipulate
the selected words.  The line is broken into words in the same fashion
that Bash does, so that several words
surrounded by quotes are considered one word.
History expansions are introduced by the appearance of the
history expansion character, which is @samp{!} by default.
@ifset BashFeatures
Only @samp{\} and @samp{'} may be used to escape the history expansion
character.
@end ifset

@ifset BashFeatures
Several shell options settable with the @code{shopt}
builtin (@pxref{Bash Builtins}) may be used to tailor
the behavior of history expansion.  If the
@code{histverify} shell option is enabled, and Readline
is being used, history substitutions are not immediately passed to
the shell parser.
Instead, the expanded line is reloaded into the Readline
editing buffer for further modification.
If Readline is being used, and the @code{histreedit}
shell option is enabled, a failed history expansion will be
reloaded into the Readline editing buffer for correction.
The @option{-p} option to the @code{history} builtin command
may be used to see what a history expansion will do before using it.
The @option{-s} option to the @code{history} builtin may be used to
add commands to the end of the history list without actually executing
them, so that they are available for subsequent recall.
This is most useful in conjunction with Readline.

The shell allows control of the various characters used by the
history expansion mechanism with the @code{histchars} variable,
as explained above (@pxref{Bash Variables}).  The shell uses
the history comment character to mark history timestamps when
writing the history file.
@end ifset

@menu
* Event Designators::	How to specify which history line to use.
* Word Designators::	Specifying which words are of interest.
* Modifiers::		Modifying the results of substitution.
@end menu

@node Event Designators
@subsection Event Designators
@cindex event designators

An event designator is a reference to a command line entry in the
history list.
Unless the reference is absolute, events are relative to the current
position in the history list.
@cindex history events

@table @asis

@item @code{!}
@ifset BashFeatures
Start a history substitution, except when followed by a space, tab,
the end of the line, @samp{=} or @samp{(} (when the
@code{extglob} shell option is enabled using the @code{shopt} builtin).
@end ifset
@ifclear BashFeatures
Start a history substitution, except when followed by a space, tab,
the end of the line, or @samp{=}.
@end ifclear

@item @code{!@var{n}}
Refer to command line @var{n}.

@item @code{!-@var{n}}
Refer to the command @var{n} lines back.

@item @code{!!}
Refer to the previous command.  This is a synonym for @samp{!-1}.

@item @code{!@var{string}}
Refer to the most recent command
preceding the current position in the history list
starting with @var{string}.

@item @code{!?@var{string}[?]}
Refer to the most recent command
preceding the current position in the history list
containing @var{string}.
The trailing
@samp{?} may be omitted if the @var{string} is followed immediately by
a newline.

@item @code{^@var{string1}^@var{string2}^}
Quick Substitution.  Repeat the last command, replacing @var{string1}
with @var{string2}.  Equivalent to
@code{!!:s/@var{string1}/@var{string2}/}.

@item @code{!#}
The entire command line typed so far.

@end table

@node Word Designators
@subsection Word Designators

Word designators are used to select desired words from the event.
A @samp{:} separates the event specification from the word designator.  It
may be omitted if the word designator begins with a @samp{^}, @samp{$},
@samp{*}, @samp{-}, or @samp{%}.  Words are numbered from the beginning
of the line, with the first word being denoted by 0 (zero).  Words are
inserted into the current line separated by single spaces.

@need 0.75
For example,

@table @code
@item !!
designates the preceding command.  When you type this, the preceding
command is repeated in toto.

@item !!:$
designates the last argument of the preceding command.  This may be
shortened to @code{!$}.

@item !fi:2
designates the second argument of the most recent command starting with
the letters @code{fi}.
@end table

@need 0.75
Here are the word designators:
 
@table @code

@item 0 (zero)
The @code{0}th word.  For many applications, this is the command word.

@item @var{n}
The @var{n}th word.

@item ^
The first argument; that is, word 1.

@item $
The last argument.

@item %
The word matched by the most recent @samp{?@var{string}?} search.

@item @var{x}-@var{y}
A range of words; @samp{-@var{y}} abbreviates @samp{0-@var{y}}.

@item *
All of the words, except the @code{0}th.  This is a synonym for @samp{1-$}.
It is not an error to use @samp{*} if there is just one word in the event;
the empty string is returned in that case.

@item @var{x}*
Abbreviates @samp{@var{x}-$}

@item @var{x}-
Abbreviates @samp{@var{x}-$} like @samp{@var{x}*}, but omits the last word.

@end table

If a word designator is supplied without an event specification, the
previous command is used as the event.

@node Modifiers
@subsection Modifiers

After the optional word designator, you can add a sequence of one or more
of the following modifiers, each preceded by a @samp{:}.

@table @code

@item h
Remove a trailing pathname component, leaving only the head.

@item t
Remove all leading pathname components, leaving the tail.

@item r
Remove a trailing suffix of the form @samp{.@var{suffix}}, leaving
the basename.

@item e
Remove all but the trailing suffix.

@item p
Print the new command but do not execute it.

@ifset BashFeatures
@item q
Quote the substituted words, escaping further substitutions.

@item x
Quote the substituted words as with @samp{q},
but break into words at spaces, tabs, and newlines.
@end ifset

@item s/@var{old}/@var{new}/
Substitute @var{new} for the first occurrence of @var{old} in the
event line.  Any delimiter may be used in place of @samp{/}.
The delimiter may be quoted in @var{old} and @var{new}
with a single backslash.  If @samp{&} appears in @var{new},
it is replaced by @var{old}.  A single backslash will quote
the @samp{&}.  The final delimiter is optional if it is the last
character on the input line.

@item &
Repeat the previous substitution.

@item g
@itemx a
Cause changes to be applied over the entire event line.  Used in
conjunction with @samp{s}, as in @code{gs/@var{old}/@var{new}/},
or with @samp{&}.

@item G
Apply the following @samp{s} modifier once to each word in the event.

@end table
